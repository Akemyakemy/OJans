# [现代汽车](https://acexam.nowcoder.com/?uid=A0EF0AABBA3E26C8# )

### 1.朋友数

![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)给定两个整数 ![x,y](https://www.nowcoder.com/equation?tex=x%2Cy)![\left(1 \leqq x \leqq y \leqq 10^9\right)](https://www.nowcoder.com/equation?tex=%5Cleft(1%20%5Cleqq%20x%20%5Cleqq%20y%20%5Cleqq%2010%5E9%5Cright))，若它们满足下列等式，则称其为朋友数：

![\quad (y - x)\bmod10 = (y + x)\bmod10](https://www.nowcoder.com/equation?tex=%5Cquad%20(y%20-%20x)%5Cbmod10%20%3D%20(y%20%2B%20x)%5Cbmod10)

现给定两个参数，每次可任选如下操作之一：

  ![\hspace{23pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B23pt%7D%5Cbullet%5C%2C)将 ![x](https://www.nowcoder.com/equation?tex=x) 增加 ![1](https://www.nowcoder.com/equation?tex=1) 或减少 ![1](https://www.nowcoder.com/equation?tex=1)；
![\hspace{23pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B23pt%7D%5Cbullet%5C%2C)将 ![y](https://www.nowcoder.com/equation?tex=y) 增加 ![1](https://www.nowcoder.com/equation?tex=1) 或减少 ![1](https://www.nowcoder.com/equation?tex=1)。
![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)请在保证操作后仍满足 ![\left(1 \leqq x \leqq y \leqq 10^9\right)](https://www.nowcoder.com/equation?tex=%5Cleft(1%20%5Cleqq%20x%20%5Cleqq%20y%20%5Cleqq%2010%5E9%5Cright)) 的前提下，计算将 ![(x,y)](https://www.nowcoder.com/equation?tex=(x%2Cy)) 变为朋友数所需的最少操作次数。

【名词解释】
![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)**朋友数**：若整数对 ![(x,y)](https://www.nowcoder.com/equation?tex=(x%2Cy)) 满足 ![(y - x)\bmod10 = (y + x)\bmod10](https://www.nowcoder.com/equation?tex=(y%20-%20x)%5Cbmod10%20%3D%20(y%20%2B%20x)%5Cbmod10)，则称其为朋友数。  

//等式左边-右边得到 x mod 5 = 0 .

```c++
#include <iostream>
#include <climits>
using namespace std;
int solve()
{
    int x,y;
    cin>>x>>y;
    if(x%5==0)
    {
        return 0;
    }
    int t1=(x/5)*5;
    int t2=t1+5;
    int d1=x-t1;
    if(t1<1) {
        d1=INT_MAX;
    }
    int d2=t2-x;
    int ops=0;
    if(t2>y)
    {
        ops=t2-y;
    }
    int res=min(d1,d2+ops);
    return res;
}
int main() {
    int t;
    cin>>t;
    while(t--){
        int res=solve();
        cout<<res<<endl;
    }
}
// 64 位输出请用 printf("%lld")
```

### 2.损坏的键盘

![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D) 程序员 Tk 在办公时频繁使用键盘，使得不同按键因使用频率不同而出现磨损。对于 ![26](https://www.nowcoder.com/equation?tex=26) 个英文字母按键，按照字母顺序，第 ![i](https://www.nowcoder.com/equation?tex=i) 个按键每次按下会打印出 ![a_i](https://www.nowcoder.com/equation?tex=a_i) 个该字母。

![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D) 给定一个长度为 ![n](https://www.nowcoder.com/equation?tex=n) 的仅包含小写字母的字符串 ![s](https://www.nowcoder.com/equation?tex=s)，请判断 Tk 是否能够打印出该字符串：能则输出 ![Yes](https://www.nowcoder.com/equation?tex=Yes)，否则输出 ![No](https://www.nowcoder.com/equation?tex=No)。

```c++
#include <iostream>
using namespace std;

void solve() {
    int n;
    cin >> n;
    int letter[26];
    for (int i = 0; i < 26; i++) {
        cin >> letter[i];
    }
    string s;
    cin >> s;

    int i = 0;
    while (i < n) {
        char c = s[i];
        int idx = c - 'a';

        // 如果该字母的按键值为0，直接失败
        if (letter[idx] == 0) {
            cout << "No" << endl;
            return;
        }

        // 计算连续相同字母的长度
        int count = 1;
        int j = i + 1;
        while (j < n && s[j] == c) {
            count++;
            j++;
        }

        // 检查长度是否能被letter[idx]整除
        if (count % letter[idx] != 0) {
            cout << "No" << endl;
            return;
        }

        i = j;  // 移动到下一个不同字符的位置
    }

    cout << "Yes" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

### 3.包包的XOR

![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)包包有一个长度为 ![n](https://www.nowcoder.com/equation?tex=n) 的数组 ![a](https://www.nowcoder.com/equation?tex=a) 和一个非负整数 ![k](https://www.nowcoder.com/equation?tex=k)。
![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)定义对数组 ![a](https://www.nowcoder.com/equation?tex=a) 的一次操作为：
![\hspace{23pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B23pt%7D%5Cbullet%5C%2C)对于数组 ![a](https://www.nowcoder.com/equation?tex=a) 中的每个元素 ![a_i](https://www.nowcoder.com/equation?tex=a_i)，更新 ![a_i=a_i \oplus k](https://www.nowcoder.com/equation?tex=a_i%3Da_i%20%5Coplus%20k)，其中 ![\oplus](https://www.nowcoder.com/equation?tex=%5Coplus) 代表按位异或运算。
![\hspace{23pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B23pt%7D%5Cbullet%5C%2C)在更新后的数组 ![a](https://www.nowcoder.com/equation?tex=a) 中移除最小的元素。如果存在多个最小元素，仅移除一个。
![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)注意到每次操作后，数组 ![a](https://www.nowcoder.com/equation?tex=a) 的长度会减少 ![1](https://www.nowcoder.com/equation?tex=1)。
![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)现在包包想让你求出：在恰好 ![n-1](https://www.nowcoder.com/equation?tex=n-1) 次操作后，![a](https://www.nowcoder.com/equation?tex=a) 中剩余的唯一元素的值。

//x ^ k ^ k = x .

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 200000 + 100;
int n, k;
int num[maxn];
bool del[maxn];
set<pair<int, int>> st[2];

int main() {
#ifdef ExRoc
    freopen("test.txt", "r", stdin);
#endif // ExRoc
    ios::sync_with_stdio(false);

    cin >> n >> k;
    for (int i = 0; i < n; ++i) {
        cin >> num[i];
        st[0].insert({num[i], i});
        st[1].insert({num[i] ^ k, i});
    }
    for (int i = 1; i < n; ++i) {
        while (del[st[i & 1].begin()->second]) {
            st[i & 1].erase(st[i & 1].begin());
        }
        del[st[i & 1].begin()->second] = true;
        st[i & 1].erase(st[i & 1].begin());
    }
    while (del[st[(n & 1) ^ 1].begin()->second]) {
        st[(n & 1) ^ 1].erase(st[(n & 1) ^ 1].begin());
    }
    cout << st[(n & 1) ^ 1].begin()->first << endl;

    return 0;
}
```

### 4.小C的无限循环小数

![\hspace{15pt}](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D)小C是一位数学爱好者，他想知道在给定分子 ![p](https://www.nowcoder.com/equation?tex=p)，并限定分母不超过 ![q](https://www.nowcoder.com/equation?tex=q) 的情况下，分数 ![\tfrac{p}{i}](https://www.nowcoder.com/equation?tex=%5Ctfrac%7Bp%7D%7Bi%7D) 在 ![k](https://www.nowcoder.com/equation?tex=k) 进制中有多少个是无限循环小数。

\## 【名词解释】
![\hspace{15pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D%5Cbullet%5C%2C) **有限小数**：有限小数是指一个分数在某一进制下的小数表示能够在有限位后结束。例如，在十进制中，![\tfrac{1}{2}=0.5](https://www.nowcoder.com/equation?tex=%5Ctfrac%7B1%7D%7B2%7D%3D0.5) 是一个有限小数。
![\hspace{15pt}\bullet\,](https://www.nowcoder.com/equation?tex=%5Chspace%7B15pt%7D%5Cbullet%5C%2C) **无限循环小数**：无限循环小数是指一个分数在某一进制下的小数表示既不终止且从某一点开始呈现周期性重复。例如，在十进制中，![\tfrac{1}{3}=0.\overline{3}](https://www.nowcoder.com/equation?tex=%5Ctfrac%7B1%7D%7B3%7D%3D0.%5Coverline%7B3%7D) 就是一个无限循环小数。

```// 关键数学知识：有限小数的判定条件
一个分数`p/i`在`k`进制下是**有限小数**的充要条件是：

- 先将分数约分为最简形式`a/b`（即`a`和`b`互质）
- 分母`b`的所有质因数都必须是`k`的质因数

反之，如果`b`存在不属于`k`的质因数，则该分数在`k`进制下是**无限循环小数**
```

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<typename T> void print(const T& t) { cout << t << "\n"; }
template<typename T, typename... Arg> void print(const T& t, const Arg&... args) { cout << t << " "; print(args...); }

int p, q, k, res;
vector<int> priems;

vector<int> cal(int x) {
    vector<int> v;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            v.push_back(i);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) v.push_back(x);
    return v;
}

vector<int> K;
void dfs(int x, int u) {
    if (x > q) return;
    if (u >= K.size()) {
        if (x <= q) res++;
    }
    else {
        while (x <= q && x >= 1) {
            dfs(x, u + 1);
            x *= K[u];
        }
    }
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> p >> q >> k;
    K = cal(k);
    for (int i : K) {
        while (p % i == 0) p /= i;
    }
    for (int i = 1; i <= p / i; i++) {
        if (p % i == 0) {
            dfs(i, 0);
            if (p / i != i) dfs(p / i, 0);
        }
    }
    print(q - res);
    return 0;
}
```



